import pytest
import json
from unittest.mock import MagicMock, AsyncMock, patch
from pathlib import Path
from wet_mcp.sources.crawler import download_media
# from wet_mcp.config import settings # We don't need settings here, we just need a path

@pytest.mark.asyncio
async def test_arbitrary_write_vulnerability(tmp_path):
    """
    Test that we CANNOT write to an arbitrary directory.
    """
    # Create a directory that is definitely NOT the configured download_dir
    # In tests, download_dir is usually mocked or defaults to ~/.wet-mcp/downloads
    # We will use tmp_path as our 'arbitrary' directory, assuming it is not the configured download_dir.
    # To be safe, we should mock settings.download_dir to something else.

    safe_dir = tmp_path / "safe_downloads"
    safe_dir.mkdir()

    arbitrary_dir = tmp_path / "arbitrary"
    arbitrary_dir.mkdir()

    target_file = arbitrary_dir / "pwned.txt"

    # Mock network response (though it shouldn't reach this point)
    mock_client = AsyncMock()
    mock_response = MagicMock()
    mock_response.content = b"pwned"
    mock_response.raise_for_status = MagicMock()
    mock_client.get.return_value = mock_response

    mock_client_cls = MagicMock()
    mock_client_cls.return_value.__aenter__.return_value = mock_client
    mock_client_cls.return_value.__aexit__.return_value = None

    url = "http://example.com/pwned.txt"

    # We patch settings to ensure arbitrary_dir is NOT allowed
    with patch("wet_mcp.config.settings.download_dir", str(safe_dir)):
        with patch("httpx.AsyncClient", mock_client_cls):
            # We pass arbitrary_dir as output_dir
            # This should now FAIL
            result_json = await download_media([url], str(arbitrary_dir))

    results = json.loads(result_json)

    # We expect an error
    if isinstance(results, dict) and "error" in results:
        assert "Security Alert" in results["error"]
        assert "Path traversal" in results["error"] or "Unsafe output directory" in results["error"]
    elif isinstance(results, list) and len(results) > 0 and "error" in results[0]:
         # It's possible it returns a list of errors if we implemented it that way,
         # but blocking the whole operation is better.
         # For now, let's assume it returns a dict with error.
         pass
    else:
        # If it returns an empty list or success, that's a failure of the test
        # currently, before fix, it returns a list of successes.
        pass

    # CRITICAL CHECK: The file must NOT exist
    assert not target_file.exists(), "Vulnerability Exploit Successful: File was written to arbitrary directory!"
